"""
漏洞原因分析器 - 第二阶段
负责深入分析漏洞的技术原理、代码层面的问题和修复方案
"""

import os
from smolagents import (
    MemoryCompressedCodeAgent,
    ListDirectoryTool,
    ReadFileTool,
    WriteFileTool,
    EditFileTool,
    FileSearchTool,
    FileContentSearchTool,
    ShellTools,
)
from smolagents.web_tools import WebTools

class VulnerabilityAnalyzer:
    """漏洞原因分析器"""
    
    def __init__(self, model, max_steps=30, search_engine="duckduckgo", output_dir="output"):
        self.model = model
        self.max_steps = max_steps
        self.search_engine = search_engine
        self.output_dir = output_dir
        self.repo_dir = os.path.join(output_dir, "repo")
        self.agent = self._create_agent()
    
    def _create_agent(self):
        """创建专门用于漏洞技术分析的agent"""
        
        # 确保仓库目录存在
        os.makedirs(self.repo_dir, exist_ok=True)
        
        # 基础工具
        tools = []
        
        # Web工具 - 用于搜索和访问网页
        web_tools = WebTools(model=self.model, text_limit=100000, search_engine=self.search_engine)
        tools.extend(web_tools.tools)
        
        # 文件系统工具 - 用于浏览和分析代码
        filesystem_tools = [
            ListDirectoryTool(),      # 列出目录内容
            ReadFileTool(),           # 读取文件
            WriteFileTool(),          # 写入文件
            EditFileTool(),           # 编辑文件
            FileSearchTool(),         # 搜索文件
            FileContentSearchTool(),  # 搜索文件内容
        ]
        tools.extend(filesystem_tools)
        
        # Shell工具 - 用于执行git命令和其他系统命令
        shell_tools = ShellTools(
            default_page_size=20480,    # 20KB分页大小，超过此大小自动分页
            include_system_info=True    # 包含系统信息工具
        )
        tools.extend(shell_tools.tools)
        
        agent = MemoryCompressedCodeAgent(
            model=self.model,
            tools=tools,
            max_steps=self.max_steps,
            additional_authorized_imports=["*"],
            verbosity_level=2,
            planning_interval=6,
            name="vulnerability_analyzer",
            description=f"""漏洞分析专家，具备深厚的安全技术功底，能够理解复杂的技术细节,专门负责漏洞的技术分析, 能够深入分析漏洞的技术原理，包括但不限于：
            
            1. 漏洞的根本原因和触发机制
            2. 代码层面的缺陷分析
            3. 攻击向量和利用条件
            4. 缓解措施分析
            5. 修复代码分析
            6. 相关漏洞的对比研究
            
            可用工具：
            - Web搜索和页面访问工具（search_web, visit_page等）
            - 文件系统工具：
              * list_directory: 列出目录内容
              * read_file: 读取文件内容
              * write_file: 写入文件
              * edit_file: 编辑文件
              * file_search: 搜索文件
              * file_content_search: 搜索文件内容
            - Shell工具：
              * execute_command: 执行系统命令（包括git命令）
              * get_system_info: 获取系统信息
            
            工作目录：{self.repo_dir}
            """,
        )
        
        return agent
    
    def run(self, task):
        """执行漏洞技术分析任务"""
        print(f"🔬 开始分析漏洞技术原理...")
        
        enhanced_task = f"""
{task}

---

深度分析要求：
1. **源码级分析**：
   - 首先从NVD、官方公告等处查找漏洞相关的GitHub仓库和commit信息
   - 尝试使用`visit_page`通过url访问github源码时，要使用raw链接，例如：要访问`https://github.com/containerd/containerd/blob/v2.1.0/pkg/archive/tar.go`，实际应该访问`https://raw.githubusercontent.com/containerd/containerd/v2.1.0/pkg/archive/tar.go`
   - 如果从网上找不到确定的修复commit，若该代码仓支持git，则可使用`git clone`下载到{self.repo_dir}目录下，进行本地分析
   - 在进行本地分析时，可使用git命令分析commit历史，找出漏洞相关的修复补丁，并使用文件系统工具读取源码文件，进行详细分析
     - **重要**：对于git diff等可能产生长输出的命令，系统会自动分页管理：
       * 使用`exec_cmd(command="git diff xxx", command_id="diff_main")`执行命令并分配命令ID，不同的命令使用不同的ID，或者让系统自动分配ID
       * 输出超过20KB时会自动分页显示，可以使用以下工具浏览：
         - `cmd_page_down`和`cmd_page_up`：逐页翻页查看
         - `get_cmd_page(command_id="diff_main", page_number=3)`：直接跳转到指定页面
       * 使用`list_commands`查看所有保存的命令输出
       * 使用`get_cmd_output(command_id="diff_main")`重新查看指定命令的输出
       * 可以通过`page_size`参数自定义分页大小，如`exec_cmd(command="git log", page_size=10240)`设置为10KB分页
     * **命令搜索功能**：
       - 使用`search_cmd(command_id="diff_main", keyword="vulnerability")`在指定命令输出中搜索关键词
       - 使用`search_all_cmds(keyword="CVE-2024")`在所有命令输出中搜索关键词
       - 搜索结果会显示匹配行及其上下文，默认显示1000行上下文
       - 可以通过`context_lines`参数调整上下文行数
   - 基于真实的漏洞代码和修复补丁进行原理分析
   - 完整输出关键代码片段，不要省略或总结
   - 详细解释每行代码的作用和问题所在
   
2. **技术细节深挖**：
   - 深入分析数据流、控制流和时序关系
   - 关注边界条件、异常处理、并发控制等细节
   - 分析漏洞在不同场景下的表现差异
   
3. **修复方案验证**：
   - 对比修复前后的代码差异
   - 分析修复方案的完整性和有效性
   - 考虑是否存在绕过修复的可能性
   
4. **实际利用场景**：
   - 分析真实攻击场景中的利用条件
   - 考虑不同环境下的利用难度和影响
   - 关注与其他安全机制的交互

注意事项：
- 首先尝试从NVD、官方公告等处查找漏洞相关的GitHub仓库信息
- 代码仓库管理策略：
  * 如果{self.repo_dir}目录下已存在对应仓库，使用`git pull`更新到最新代码
  * 如果仓库不存在，使用`git clone`下载仓库到{self.repo_dir}/[repo_name]
  * 多个仓库可以并存在{self.repo_dir}目录下
- Git操作示例：
  * 检查仓库是否存在：使用`list_directory`工具查看{self.repo_dir}目录内容
  * 克隆新仓库：`git clone https://github.com/user/repo.git {self.repo_dir}/repo_name`
  * 更新已有仓库：`git -C {self.repo_dir}/repo_name pull`
  * 查看提交历史：`git -C {self.repo_dir}/repo_name log --oneline --grep="CVE-XXXX"`
  * 查看具体提交：`git -C {self.repo_dir}/repo_name show <commit_hash>`
  * 对比代码差异：`git -C {self.repo_dir}/repo_name diff <commit1>..<commit2> -- path/to/file`
- 使用read_file工具读取具体的源码文件进行分析
- 使用list_directory工具浏览目录结构
- 使用file_search和file_content_search工具搜索相关文件
- 工作目录：{self.repo_dir}
- 生成的分析结果要使用`final_answer`工具完整输出

请按照以下markdown结构输出技术分析结果：

## 漏洞分析
根据搜集到的信息，总结漏洞的成因及技术原理

### 技术原理
#### 深度源码分析
包括但不限于以下分析要点：
- 完整展示漏洞相关的源代码（不要省略）
- 逐行分析代码逻辑和问题所在
- 详细说明漏洞触发的条件和时机
- 分析数据流和控制流的异常路径

#### 修复代码分析
包括但不限于以下分析要点：
- 补丁代码的commit id
- 展示完整的修复补丁代码
- 对比修复前后的关键差异
- 分析修复方案的技术原理
- 评估修复的完整性和有效性

### 漏洞触发机制
详细分析漏洞的触发条件、时序要求和环境依赖：
- 具体的触发步骤和操作序列
- 关键的时间窗口和竞争条件
- 环境配置和系统状态要求

### 排查指导
根据漏洞产生的原理，给出排查指导，要列出具体的排查步骤，需要包含多种排查方法，如：
1. 根据漏洞组件版本进行排查
2. 根据触发漏洞的现象进行排查，构造简单的检测脚本

### 缓解措施
根据漏洞的成因及技术原理，给出缓解措施，需要列出具体的缓解措施执行步骤

### 参考链接
给出获得上述事实的参考链接，特别是源码和补丁链接
1. 
2. 
...
n. 

"""
        
        result = self.agent.run(enhanced_task)
        return result
    
    def get_repo_dir(self):
        """获取仓库目录路径"""
        return self.repo_dir
    
    def list_repos(self):
        """列出已下载的仓库"""
        if os.path.exists(self.repo_dir):
            repos = [d for d in os.listdir(self.repo_dir) 
                    if os.path.isdir(os.path.join(self.repo_dir, d))]
            return repos
        return []

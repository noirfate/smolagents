"""
漏洞分析质量校验器
负责检查每个阶段的分析结果质量，确保达到预期标准
"""

import re
from typing import Dict, List, Tuple
from smolagents import (
    CodeAgent,
)


class VulnerabilityAnalysisValidator:
    """漏洞分析质量校验器"""
    
    def __init__(self, model, max_steps=15):
        self.model = model
        self.max_steps = max_steps
        self.agent = self._create_agent()
    
    def _create_agent(self):
        """创建专门用于质量校验的agent"""
        agent = CodeAgent(
            model=self.model,
            tools=[],
            max_steps=self.max_steps,
            additional_authorized_imports=["*"],
            verbosity_level=1,
            planning_interval=3,
            name="vulnerability_validator",
            description="""漏洞分析质量校验专家，负责评估漏洞分析结果的完整性、准确性和实用性。
            
            能力包括：
            1. 评估信息收集的完整性和准确性
            2. 检查技术分析的深度和逻辑性
            3. 验证POC代码的可执行性和有效性
            4. 识别分析中的缺失项和错误
            """,
        )
        
        return agent
    
    def validate_stage1_info_collection(self, result: str, vulnerability_id: str) -> Tuple[bool, List[str], int, str]:
        """
        验证第一阶段信息收集结果
        
        Returns:
            Tuple[bool, List[str], int, str]: (是否通过, 问题列表, 质量评分, 行为指导)
        """
        print("🔍 校验第一阶段：漏洞信息收集质量...")
        
        validation_task = f"""
请评估以下漏洞信息收集结果的质量：

漏洞ID: {vulnerability_id}

分析结果:
{result}

---

请从以下维度进行评估：

1. **基础信息完整性** (25分)：
   - CVE编号是否正确
   - CVSS评分是否准确
   - 漏洞类型分类是否正确
   - 影响版本和修复版本是否明确

2. **描述准确性** (25分)：
   - 漏洞描述是否准确详细
   - 技术原理概述是否正确
   - 影响范围评估是否合理

3. **参考资料质量** (25分)：
   - 是否包含官方安全公告链接
   - 是否有NVD等权威来源
   - 参考链接是否有效可访问

4. **风险评估合理性** (25分)：
   - 处置优先级是否合理
   - 利用条件分析是否准确
   - 交互要求判断是否正确

请按以下格式输出评估结果：

## 质量评估结果

### 总体评分
总分：X/100分

### 各维度评分
- 基础信息完整性：X/25分
- 描述准确性：X/25分  
- 参考资料质量：X/25分
- 风险评估合理性：X/25分

### 存在问题
1. 问题描述1
2. 问题描述2
...

### 改进建议
1. 改进建议1
2. 改进建议2
...

### 下一轮执行指导
请为下一轮执行提供具体的行为指导，包括：
- 需要重点关注的信息收集方向
- 需要补充的具体内容
- 需要修正的错误信息
- 建议的搜索关键词和查找策略
- 其他具体的执行建议

### 是否通过
通过标准：总分≥75分且无严重错误
结果：通过/不通过
"""
        
        validation_result = self.agent.run(validation_task)
        return self._parse_validation_result(validation_result)
    
    def validate_stage2_analysis(self, result: str, vulnerability_id: str) -> Tuple[bool, List[str], int, str]:
        """
        验证第二阶段技术分析结果
        
        Returns:
            Tuple[bool, List[str], int, str]: (是否通过, 问题列表, 质量评分, 行为指导)
        """
        print("🔬 校验第二阶段：漏洞技术分析质量...")
        
        validation_task = f"""
请评估以下漏洞技术分析结果的质量：

漏洞ID: {vulnerability_id}

分析结果:
{result}

---

请从以下维度进行评估：

1. **源码分析深度** (30分)：
   - 是否包含真实的漏洞代码片段
   - 代码分析是否逐行详细
   - 是否分析了修复补丁代码
   - 修复前后对比是否清晰

2. **技术原理准确性** (30分)：
   - 漏洞触发机制分析是否正确
   - 数据流和控制流分析是否准确
   - 时序和条件分析是否合理
   - 根本原因定位是否准确

3. **排查指导实用性** (20分)：
   - 是否提供多种排查方法
   - 检测脚本是否可行
   - 排查步骤是否具体可操作

4. **缓解措施完整性** (20分)：
   - 是否包含根本性修复方案
   - 临时缓解措施是否可行
   - 防护建议是否全面

请按以下格式输出评估结果：

## 质量评估结果

### 总体评分
总分：X/100分

### 各维度评分
- 源码分析深度：X/30分
- 技术原理准确性：X/30分
- 排查指导实用性：X/20分
- 缓解措施完整性：X/20分

### 存在问题
1. 问题描述1
2. 问题描述2
...

### 改进建议
1. 改进建议1
2. 改进建议2
...

### 下一轮执行指导
请为下一轮执行提供具体的行为指导，包括：
- 需要深入分析的源码位置和文件
- 需要查找的具体commit或补丁链接
- 需要重点关注的技术细节
- 建议的代码分析方法和工具
- 需要补充的技术原理解释
- 其他具体的分析建议

### 是否通过
通过标准：总分≥75分且源码分析深度≥20分
结果：通过/不通过
"""
        
        validation_result = self.agent.run(validation_task)
        return self._parse_validation_result(validation_result)
    
    def validate_stage3_exploitation(self, result: str, vulnerability_id: str) -> Tuple[bool, List[str], int, str]:
        """
        验证第三阶段利用分析结果
        
        Returns:
            Tuple[bool, List[str], int, str]: (是否通过, 问题列表, 质量评分, 行为指导)
        """
        print("⚔️ 校验第三阶段：漏洞利用分析质量...")
        
        validation_task = f"""
请评估以下漏洞利用分析结果的质量：

漏洞ID: {vulnerability_id}

分析结果:
{result}

---

请从以下维度进行评估：

1. **复现环境完整性** (25分)：
   - Dockerfile是否完整可用
   - 环境配置是否详细
   - 依赖安装是否完整
   - 环境搭建步骤是否清晰

2. **POC代码质量** (35分)：
   - POC代码是否完整可执行
   - 代码逻辑是否正确
   - 是否包含错误处理
   - 是否有成功验证机制
   - 技术细节解释是否详细

3. **利用步骤准确性** (25分)：
   - 操作步骤是否详细具体
   - 时序要求是否明确
   - 触发条件是否准确
   - 预期结果是否明确

4. **实用性和可操作性** (15分)：
   - 是否提供完整的操作指南
   - 验证方法是否可行
   - 是否考虑了实际环境差异

请按以下格式输出评估结果：

## 质量评估结果

### 总体评分
总分：X/100分

### 各维度评分
- 复现环境完整性：X/25分
- POC代码质量：X/35分
- 利用步骤准确性：X/25分
- 实用性和可操作性：X/15分

### 存在问题
1. 问题描述1
2. 问题描述2
...

### 改进建议
1. 改进建议1
2. 改进建议2
...

### 下一轮执行指导
请为下一轮执行提供具体的行为指导，包括：
- 需要搜索的POC代码仓库和资源
- 需要完善的环境配置和依赖
- 需要修正的POC代码逻辑
- 需要补充的利用步骤细节
- 建议的验证方法和测试策略
- 其他具体的利用分析建议

### 是否通过
通过标准：总分≥75分且POC代码质量≥25分
结果：通过/不通过
"""
        
        validation_result = self.agent.run(validation_task)
        return self._parse_validation_result(validation_result)
    
    def _parse_validation_result(self, validation_result: str) -> Tuple[bool, List[str], int, str]:
        """
        解析校验结果
        
        Returns:
            Tuple[bool, List[str], int, str]: (是否通过, 问题列表, 质量评分, 行为指导)
        """
        # 提取总分
        score_match = re.search(r'总分：(\d+)/100分', validation_result)
        total_score = int(score_match.group(1)) if score_match else 0
        
        # 提取问题列表
        problems = []
        problem_section = re.search(r'### 存在问题\s*\n(.*?)### 改进建议', validation_result, re.DOTALL)
        if problem_section:
            problem_lines = problem_section.group(1).strip().split('\n')
            for line in problem_lines:
                line = line.strip()
                if line and (line.startswith('1.') or line.startswith('2.') or line.startswith('3.') or 
                           line.startswith('4.') or line.startswith('5.') or line.startswith('-')):
                    problems.append(line)
        
        # 提取行为指导
        improvement_guidance = ""
        guidance_section = re.search(r'### 下一轮执行指导\s*\n(.*?)### 是否通过', validation_result, re.DOTALL)
        if guidance_section:
            improvement_guidance = guidance_section.group(1).strip()
        
        # 提取是否通过
        pass_match = re.search(r'结果：(通过|不通过)', validation_result)
        is_passed = pass_match.group(1) == '通过' if pass_match else False
        
        return is_passed, problems, total_score, improvement_guidance


class QualityControlConfig:
    """质量控制配置"""
    
    def __init__(self):
        self.max_retries = 2  # 每个阶段最大重试次数
        self.min_score_threshold = 75  # 最低分数要求
        self.enable_validation = True  # 是否启用校验
        self.validation_timeout = 300  # 校验超时时间(秒)
    
    def set_max_retries(self, retries: int):
        """设置最大重试次数"""
        self.max_retries = max(0, retries)
        return self
    
    def set_score_threshold(self, threshold: int):
        """设置分数阈值"""
        self.min_score_threshold = max(0, min(100, threshold))
        return self
    
    def disable_validation(self):
        """禁用校验"""
        self.enable_validation = False
        return self
